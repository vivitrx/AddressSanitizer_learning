# 概念1：虚拟内存与物理内存

## 理论部分

### 什么是虚拟地址空间？

每个Linux进程都有自己独立的虚拟地址空间，这就像每个进程都有一个"私人的内存地图"。

**关键概念：**
- **虚拟地址**：进程看到的内存地址（如0x400000）
- **物理地址**：实际RAM芯片上的地址
- **页表**：操作系统维护的映射表，将虚拟地址转换为物理地址

### 为什么需要虚拟内存？

1. **隔离性**：每个进程认为自己拥有整个内存空间
2. **安全性**：一个进程无法访问另一个进程的内存
3. **效率**：只有实际使用的内存才会分配物理页面

### 进程如何看到内存？

在64位Linux系统中，进程的虚拟地址空间通常布局如下：

```
+----------------------+ 0xFFFFFFFFFFFFFFFF (最大地址)
|      内核空间        |
+---------------------- 0x800000000000000
|      栈              |  ↓ 向下增长
|      ...             |
|      环境变量        |
|      命令行参数      |
+---------------------- 
|                      |
|      内存映射段       |  ↑ 向上增长
|      (共享库等)      |
|                      |
+---------------------- 
|      堆              |  ↑ 向上增长
|      ...             |
+----------------------
|      BSS段           |
|      (未初始化数据)   |
+----------------------
|      数据段          |
|      (已初始化数据)   |
+----------------------
|      代码段          |
|      (程序指令)       |
+---------------------- 0x400000 (通常起始地址)
|      保留区域        |
+---------------------- 0x0 (最小地址)
```

### 什么是内存页面？

- **页面**：内存管理的基本单位
- **页面大小**：通常是4KB（可通过`getpagesize()`查看）
- **页面对齐**：内存分配通常按页面边界对齐

## 实验部分

### 实验1：查看进程内存布局

让我们写一个程序来显示自己的内存布局信息：

```c
// 文件：src/experiments/memory_layout.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    printf("=== 内存布局信息 ===\n");
    printf("页面大小: %d 字节\n", getpagesize());
    
    // 在不同段分配变量
    int stack_var = 42;                    // 栈变量
    static int bss_var;                     // BSS段（未初始化）
    static int data_var = 100;              // 数据段（已初始化）
    int *heap_var = malloc(sizeof(int));    // 堆变量
    
    printf("栈变量地址:     %p\n", (void*)&stack_var);
    printf("BSS变量地址:    %p\n", (void*)&bss_var);
    printf("数据段变量地址: %p\n", (void*)&data_var);
    printf("堆变量地址:     %p\n", (void*)heap_var);
    printf("main函数地址:   %p\n", (void*)main);
    
    // 查看进程的内存映射
    printf("\n=== 内存映射信息 ===\n");
    printf("查看 /proc/%d/maps 查看详细内存映射\n", getpid());
    printf("按Enter键继续...");
    getchar();
    
    free(heap_var);
    return 0;
}
```

### 实验2：理解地址空间

让我们验证虚拟地址和物理地址的概念：

```c
// 文件：src/experiments/address_space.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    printf("=== 虚拟地址空间验证 ===\n");
    
    // 父进程中分配内存
    int *shared = malloc(sizeof(int));
    *shared = 123;
    printf("父进程 - 变量值: %d, 地址: %p\n", *shared, (void*)shared);
    
    pid_t pid = fork();
    if (pid == 0) {
        // 子进程
        printf("子进程 - 变量值: %d, 地址: %p\n", *shared, (void*)shared);
        *shared = 456;  // 修改值
        printf("子进程修改后 - 变量值: %d, 地址: %p\n", *shared, (void*)shared);
        exit(0);
    } else {
        // 父进程等待子进程结束
        wait(NULL);
        printf("父进程等待后 - 变量值: %d, 地址: %p\n", *shared, (void*)shared);
    }
    
    free(shared);
    return 0;
}
```

## 理解部分

### 关键问题解答

**Q: 为什么父子进程看到相同的地址但不同的值？**
A: 这就是写时复制（Copy-on-Write）机制。fork()后父子进程共享相同的物理页面，但当任一进程尝试写入时，操作系统会创建该页面的副本。

**Q: 虚拟地址有什么好处？**
A: 
1. **简化编程**：程序员不需要关心物理内存布局
2. **提高安全性**：进程间内存隔离
3. **优化内存使用**：只有需要时才分配物理内存

**Q: 页面大小为什么是4KB？**
A: 这是硬件和操作系统的设计选择，平衡了内存管理开销和内部碎片。大多数现代系统支持大页面（2MB, 1GB）来减少TLB未命中。

### 与ASan的关系

理解虚拟内存对ASan至关重要，因为：
1. **mmap**：ASan使用mmap分配虚拟内存页面
2. **mprotect**：ASan通过修改页面权限来创建"保护页"
3. **地址计算**：ASan需要精确计算影子内存和保护页的位置

## 下一步

掌握了虚拟内存基础后，我们就可以学习：
- **mmap系统调用**：如何分配虚拟内存
- **mprotect**：如何控制内存访问权限
- **信号处理**：如何捕获非法内存访问

---

*准备好进入下一个概念了吗？让我们学习mmap系统调用！*
