# 🔍 VS Code 信号调试完整指南

## 🎯 概述

本指南专门针对在VS Code GUI调试器中观察信号处理的全过程，解决调试器拦截信号的问题。

## 🚀 快速开始

### **步骤1：选择正确的调试配置**

在VS Code调试面板中选择以下配置之一：

- **🔍 信号调试: sigaction()处理器观察** - 用于观察sigaction()工作
- **🔍 信号调试: signal() vs sigaction()对比** - 对比两种方法
- **🔍 信号调试: 简单sigaction测试** - 最简单的测试环境

### **步骤2：启动调试**

1. 按 `F5` 或点击调试按钮
2. 程序会在 `main()` 函数入口处停止
3. 按 `F5` 继续执行到 `pause()`

### **步骤3：发送信号**

在新终端中：
```bash
# 获取进程ID（程序启动时会显示）
# 发送SIGINT信号
./build/bin/03_signal_sender <进程ID> 2

# 或者使用命令行
kill -2 <进程ID>
```

### **步骤4：观察信号处理**

信号发送后，调试器会自动在信号处理器处停止！

## 🔧 关键配置解释

### **`handle SIGINT nostop noprint pass` 含义**

| 参数 | 作用 | 说明 |
|------|------|------|
| `nostop` | 不停止调试 | 收到信号时不中断调试，让程序处理 |
| `noprint` | 不打印信息 | 调试器不显示信号接收信息 |
| `pass` | 传递给程序 | 将信号传递给目标程序处理 |

### **断点设置**

- `break advanced_handler` - 在sigaction()处理器设置断点
- `break simple_handler` - 在signal()处理器设置断点

## 🎯 调试体验

### **1. 启动调试**
```
🔍 信号处理器实验 - signal() vs sigaction()
进程ID: 12345
========================================
```

### **2. 运行到pause()**
程序执行到：
```c
pause(); // ← 在这里等待信号
```

### **3. 发送信号**
```bash
./build/bin/03_signal_sender 12345 2
```

### **4. 断点命中**
调试器会在处理器处停止：
```c
void advanced_handler(int sig) { // ← 调试器在这里停止
    printf("⚡ 高级处理器收到信号: %d (%s)\n", sig, strsignal(sig));
    // ...
}
```

## 📊 调试面板观察要点

### **变量面板**
```
├─ sig = 2                    // 信号编号
├─ strsignal(sig) = "Interrupt" // 信号名称
└─ getpid() = 12345            // 进程ID
```

### **调用栈面板**
```
#3 advanced_handler(sig=2) at 02_signal_handler.c:XX
#2 <signal handler called> 
#1 main() at 02_signal_handler.c:XX
```

### **监视面板**
添加监视表达式：
- `sig` - 观察信号编号
- `getpid()` - 观察进程ID
- `&sig` - 观察信号地址

## 🎮 调试快捷键

| 快捷键 | 功能 | 用途 |
|--------|------|------|
| `F5` | 继续执行 | 从断点继续 |
| `F10` | 单步跳过 | 逐行执行 |
| `F11` | 单步进入 | 进入函数内部 |
| `Shift+F5` | 停止调试 | 结束调试 |

## 🔍 对比实验

### **signal() vs sigaction() 对比**

1. **启动 "🔍 信号调试: signal() vs sigaction()对比"**
2. 在 `simple_handler` 设置断点
3. 观察signal()的行为：
   - 需要重新注册
   - 可能的可靠性问题

4. **切换到 "🔍 信号调试: sigaction()处理器观察"**
5. 在 `advanced_handler` 设置断点
6. 观察sigaction()的优势：
   - 自动保持处理器
   - 更可靠的机制

## 💡 调试技巧

### **1. 多信号测试**
```c
// 在循环中可以测试多个信号
for (int i = 0; i < 3; i++) {
    pause(); // 每次都会等待信号
    printf("第%d次信号处理完成\n", i + 1);
}
```

### **2. 条件断点**
在处理器中设置条件断点：
```c
if (sig == SIGINT) { // 只在SIGINT时停止
    // 断点条件
}
```

### **3. 信号掩码观察**
在 `test_signal_masking()` 中：
- 观察信号被阻塞的情况
- 验证信号处理的时序

## 🐛 常见问题解决

### **问题1：调试器仍然拦截信号**
**解决**：确保使用了正确的调试配置，检查 `setupCommands`

### **问题2：断点不命中**
**解决**：确认处理器函数名正确，检查符号表

### **问题3：信号发送失败**
**解决**：检查进程ID，确认信号发送工具权限

## 🎉 学习目标

通过这个调试环境，你将能够：

1. **观察信号触发机制**
2. **理解处理器调用过程**
3. **对比signal()和sigaction()差异**
4. **掌握信号处理调试技巧**
5. **为ASan实现打下基础**

## 📝 调试记录模板

```
=== 信号调试记录 ===
时间: YYYY-MM-DD HH:MM:SS
测试: sigaction()处理器观察
信号: SIGINT (2)
观察结果:
- 处理器正确触发 ✅
- 信号参数正确传递 ✅
- 程序正常继续 ✅
学习心得: ...
```

---

**🚀 现在开始你的信号调试之旅吧！**

选择合适的调试配置，发送信号，观察整个过程。你会发现信号处理的世界原来如此清晰！
