# 信号实验调试指南

## 🎯 目标
使用VS Code调试器逐步观察Linux信号的处理过程，深入理解"软件中断"机制。

## 📋 准备工作

### 1. 环境检查
确保你已安装：
- VS Code
- C/C++ 扩展
- GDB调试器：`sudo apt install gdb`
- 构建工具：`sudo apt install cmake build-essential`

### 2. 项目已配置
- ✅ CMakeLists.txt 已配置（包含调试符号 `-g -O0`）
- ✅ VS Code 调试配置已创建（`.vscode/launch.json`）
- ✅ 编译任务已配置（`.vscode/tasks.json`）
- ✅ 实验程序已编译完成

## 🚀 开始调试

### 方法1: 使用VS Code界面调试

#### 步骤1: 打开调试面板
1. 在VS Code中按 `Ctrl+Shift+D` 打开调试面板
2. 在顶部下拉菜单选择调试配置：
   - "调试实验1: 信号基础观察" (空指针解引用)
   - "调试实验1: 除零错误 (SIGFPE)" 
   - "调试实验1: 非法指令 (SIGILL)"
   - "调试实验1: 程序中止 (SIGABRT)"

#### 步骤2: 设置断点
在 `01_signal_basics.c` 中设置断点：
```c
// 在这些行设置断点（点击行号左侧）
void signal_observer(int sig) {           // ← 断点1: 信号处理器入口
    printf("🚨 捕获到信号: %d (%s)\n", sig, strsignal(sig));
    printf("进程ID: %d\n", getpid());    // ← 断点2: 查看进程信息
    printf("这是信号处理器，程序即将终止...\n");
}
```

#### 步骤3: 开始调试
1. 按 `F5` 或点击绿色播放按钮开始调试
2. 观察程序输出
3. 当触发信号时，调试器会在断点处暂停

#### 步骤4: 调试器操作
- **变量窗口**: 查看当前信号编号 `sig`
- **调用堆栈**: 查看信号是如何被触发的
- **监视窗口**: 添加表达式如 `strsignal(sig)` 查看信号名称
- **调试控制台**: 执行GDB命令

### 方法2: 使用VS Code任务

#### 步骤1: 打开命令面板
按 `Ctrl+Shift+P`，输入 "Tasks: Run Task"

#### 步骤2: 选择任务
- `configure_cmake`: 首次配置（已完成）
- `build_signal_experiments`: 编译程序
- `run_experiment_1`: 运行实验（会提示选择测试编号）

## 🔍 调试实验详解

### 实验1.1: 空指针解引用 (SIGSEGV)
**调试配置**: "调试实验1: 信号基础观察"

**观察重点**:
1. 程序如何从正常的代码执行跳转到信号处理器
2. `sig` 变量的值应该是 `11` (SIGSEGV)
3. 调用堆栈显示信号触发的位置

**预期输出**:
```
🚨 捕获到信号: 11 (Segmentation fault)
进程ID: 20100
这是信号处理器，程序即将终止...
```

### 实验1.2: 除零错误 (SIGFPE)
**调试配置**: "调试实验1: 除零错误 (SIGFPE)"

**观察重点**:
1. `sig` 变量的值应该是 `8` (SIGFPE)
2. 对比SIGSEGV和SIGFPE的区别

**预期输出**:
```
🚨 捕获到信号: 8 (Floating point exception)
进程ID: 20100
这是信号处理器，程序即将终止...
```

### 实验1.3: 非法指令 (SIGILL)
**调试配置**: "调试实验1: 非法指令 (SIGILL)"

**观察重点**:
1. `sig` 变量的值应该是 `4` (SIGILL)
2. 查看反汇编视图理解非法指令

**预期输出**:
```
🚨 捕获到信号: 4 (Illegal instruction)
进程ID: 20100
这是信号处理器，程序即将终止...
```

### 实验1.4: 程序中止 (SIGABRT)
**调试配置**: "调试实验1: 程序中止 (SIGABRT)"

**观察重点**:
1. `sig` 变量的值应该是 `6` (SIGABRT)
2. 这是主动调用abort()触发的信号

**预期输出**:
```
🚨 捕获到信号: 6 (Aborted)
进程ID: 20100
这是信号处理器，程序即将终止...
```

## 🧠 深度观察技巧

### 1. 查看信号处理机制
在调试器中，观察：
- 信号处理器是如何被调用的
- 从用户态到内核态再到用户态的转换
- 信号处理器的执行上下文

### 2. 对比有无信号处理器
1. 先注释掉 `setup_observer()` 调用
2. 运行程序观察默认行为（直接崩溃）
3. 恢复信号处理器，对比差异

### 3. 使用GDB命令
在调试控制台中执行：
```gdb
info signals          # 查看所有信号信息
handle SIGSEGV print  # 设置信号处理行为
backtrace            # 查看完整的调用堆栈
```

### 4. 观察内存状态
在信号处理器中：
- 查看触发信号时的内存布局
- 理解为什么访问了非法内存
- 观察寄存器状态

## 🎯 学习目标检查

通过这个实验，你应该能够回答：

✅ **信号就像"软件中断"**
- 观察到信号如何打断正常程序执行
- 理解信号处理的异步特性

✅ **SIGSEGV是什么？（段错误信号）**
- 亲眼看到SIGSEGV信号的处理过程
- 理解触发段错误的具体原因

✅ **信号和异常的关系**
- 对比不同类型的信号（SEGV, FPE, ILL, ABRT）
- 理解它们都是异常的表现形式

## 🔧 故障排除

### 问题1: 调试器无法启动
**解决方案**:
```bash
# 检查GDB是否安装
gdb --version
# 如果未安装
sudo apt install gdb
```

### 问题2: 断点不生效
**解决方案**:
1. 确保程序是用 `-g` 选项编译的（已配置）
2. 检查断点是否设置在可执行的代码行
3. 尝试重新编译程序

### 问题3: 信号处理器未被调用
**解决方案**:
1. 检查 `setup_observer()` 是否被调用
2. 确认 `signal()` 调用成功
3. 某些信号可能被系统限制

## 📚 下一步

完成这个实验后，你将：
1. 对Linux信号机制有直观理解
2. 掌握使用调试器观察系统级行为
3. 为学习ASan的信号处理部分做好准备

接下来我们将学习：
- **概念2**: 信号处理器的编写
- **概念3**: 从信号中获取调试信息

---

**祝你调试愉快！** 🚀
